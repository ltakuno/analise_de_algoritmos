%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% talk: prototype
%%% 2002/10/16
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Erstellen eines Vortrags in PDF-Format wie folgt:
%%%
%%% 1) Uebersetzen der Datei mit 
%%%    pdflatex asz
%%% 2) Wenn Features von ppower4 gewuenscht werden, dann die eben
%%%    entstandene Datei asz.pdf weiterverarbeiten mit
%%%    ./ppower4 asz.pdf vortrag.pdf
%%% 3) Die Datei vortrag.pdf kann nun mit dem Acrobat Reader angesehen
%%%    werden
%%%
%%% Fuer Testzwecke ist auch ein "normales" Uebersetzen mit LaTeX
%%% moeglich:
%%% 1) latex asz
%%% 2) dvips asz.dvi -o asz.ps -t a4 -t landscape
%%% 3) Anschauen mit ghostview
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifx\pdfoutput\undefined \documentclass[clock,landscape]{slides} \else
\documentclass[clock,landscape]{slides} \fi
%\documentclass[clock,pdftex,landscape]{slides} \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Escrevendo em português:
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc} % isso é quase redundante
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{psfrag}

\usepackage{multicol}

\usepackage{clrscode}
%----------------------------
\usepackage{tabularx}
%%% Die Datei mit dem ASZ-Layout

\usepackage{shi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amsthm} \usepackage{amsfonts}
\usepackage[colorlinks,backref]{hyperref}
%\usepackage{background}

%\usepackage{picinpar}

\hypersetup{pdftitle={Análise e projeto de algoritmos},
  pdfsubject={Análise de algoritmos}, 
  pdfauthor={Leonardo Takuno, Centro Universitário SENAC, 
  <leonardo.takuno@gmail.com>},
  pdfkeywords={acrobat, ppower4},
%  pdfpagemode={FullScreen},
  colorlinks={false},
  linkcolor={red}
}

\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Pauseneffekte mit ppower4 werden moeglich

\usepackage{pause}
\newcommand\plone{\pause\pauselevel{=1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheoremstyle{mythm}% name
  {40pt}%      Space above
  {-15pt}%      Space below
  {\sf\itshape\blue}%      Body font
  {}%         Indent amount (empty = no indent, \parindent = para indent)
  {\sf\bfseries\green}% Thm head \vspacefont
  {.}%        Punctuation after thm head
  { }%     Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%         Thm head spec (can be left empty, meaning `normal')

\theoremstyle{mythm}
\newtheorem{theorem}             {Theorem}       
\newtheorem{claim}     [theorem] {Claim}         
\newtheorem{lemma}     [theorem] {Lemma}         
\newtheorem{corollary} [theorem] {Corollary}     
\newtheorem{fact}      [theorem] {Fact}          
\newtheorem{conjecture}[theorem] {Conjecture}    

\newtheorem{problem}   [theorem] {Problema}       
\newtheorem{propriedade}  [theorem] {Propriedade}       
\newtheorem{corolario}  [theorem] {Corolário}       
\newtheorem{definition}   [theorem] {Definição}       

%%% Symbole

\newcommand{\NN}{\mathbb{N}} \newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}} \newcommand{\1}{{{\mathchoice {\rm
        1\mskip-4mu l} {\rm 1\mskip-4mu l} {\rm 1\mskip-4.5mu l} {\rm
        1\mskip-5mu l}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\let\phi\varphi
\let\epsilon\varepsilon
\let\rho\varrho
\let\tilde\widetilde
\let\approx\thickapprox
\let\sim\thicksim

\def\({\left(}
\def\){\right)}
\def\[{\left[}
\def\]{\right]}
\def\<{\langle}
\def\>{\rangle}
\let\:\colon
\def\llfloor{\left\lfloor}
\def\rrfloor{\right\rfloor}
\def\llceil{\left\lceil}
\def\rrceil{\right\rceil}

%%% Textmakros
\def\ex{\mathop{\text{\rm ex}}\nolimits} 
\def\cB{{\mathcal B}} 
\def\cG{{\mathcal G}}
\def\cS{{\mathcal S}} 
\def\cW{{\mathcal W}} 
\def\cQ{{\mathcal Q}} 
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}} 
\def\GG{{\mathbb G}} 
\def\e{{\rm e}}
\def\epsilon{{\varepsilon}} 
\def\DISC{\mathop{\textrm{\rm DISC}}\nolimits} 
\def\EIG{\mathop{\textrm{\rm EIG}}\nolimits}
\def\CIRCUIT{\mathop{\textrm{\rm CIRCUIT}}\nolimits}
\def\CYCLE{\mathop{\textrm{\rm CYCLE}}\nolimits}
\def\SUB{\mathop{\textrm{\rm SUB}}\nolimits}
\def\NSUB{\mathop{\textrm{\rm NSUB}}\nolimits}
\def\PAIR{\mathop{\textrm{\rm PAIR}}\nolimits}
\def\TFNSUB{\mathop{\textrm{\rm TFNSUB}}\nolimits}
\def\BDD{\mathop{\textrm{\rm BDD}}\nolimits}
\def\eps{\varepsilon}

\def\rmd{\text{\rm d}}
\def\wtc{\widetilde{c}\,}
\def\whc{\widehat{c}}
\def\bfb{{\bf b}}
\def\bff{{\bf f}}
\def\bft{{\bf t}}
\def\bfx{{\bf x}}
\def\bfz{{\bf z}}
\def\cB{{\mathcal B}}
\def\cD{{\mathcal D}}
\def\cG{{\mathcal G}}
\def\cM{{\mathcal M}}
\def\cN{{\mathcal N}}
\def\cR{{\mathcal R}}
\def\cS{{\mathcal S}}
\def\cW{{\mathcal W}}
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}}
\def\FF{{\mathbb F}}
\def\NN{{\mathbb N}}
\def\RR{{\mathbb R}}
\def\ZZ{{\mathbb Z}}
\def\e{{\rm e}}
\def\card{\mathop{\text{\rm card}}\nolimits}
\def\rank{\mathop{\text{\rm rank}}\nolimits}
\def\trace{\mathop{\text{\rm trace}}\nolimits}
\def\Ave{\mathop{\text{\rm Ave}}\nolimits}
\def\Bi{\mathop{\text{\rm Bi}}\nolimits}
\def\im{\mathop{\text{\rm im}}\nolimits}
\def\ind{\mathop{\text{\rm ind}}\nolimits}
\def\dist{\mathop{\text{\rm dist}}\nolimits}
\def\nDist{\mathop{\text{\rm \#Dist}}\nolimits}
\let\Dist\nDist
\def\De{D_{\rm e}}
\def\sumL{\sum\nolimits_1}
\def\sumS{\sum\nolimits_2}
\def\GF{\mathop{\text{\rm GF}}\nolimits}
\let\FF\GF
\def\Bip{\mathop{\text{\rm Bip}}\nolimits}
\def\adj{\mathop{\text{\rm adj}}\nolimits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nx}{{\hfill\vspace*{-2cm}\tiny +}}

%\newcommand{\red}[1]{\textcolor{red}{#1}}
%\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\yellow}[1]{\textcolor{yellow}{#1}}
%\newcommand{\green}[1]{\textcolor{green}{#1}}
%\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\def\red{\color[rgb]{0.7,0,0}}
\def\green{\color[rgb]{0,.8,0}}
\def\darkgreen{\color[rgb]{0.1,0.4,0.0}}
\let\dgreen\darkgreen
\def\blue{\color[rgb]{0,0,.8}}
\def\yellow{\color[rgb]{1,1,0}}
\def\black{\color[rgb]{0,0,0}}

\def\pink{\color[rgb]{1,0,1}}
\def\brown{\color[rgb]{.5,.1,.3}}
\def\lilaz{\color[rgb]{.5,0,.5}}
\def\hmmm{\color[rgb]{.3,.1,.5}}
\def\magenta{\color[rgb]{.6,.05,.05}}

\newcommand{\uc}[1]{\centerline{\underline{#1}}}
\newcommand{\pic}[1]{\fbox{picture:{#1}}}
%\renewcommand{\bf}{\mbox{}}
\newcommand{\cP}{{\cal P}} \newcommand{\cT}{{\cal T}}
\newcommand{\add}{\mbox{\rm add}} \newcommand{\pr}{\mbox{\rm Pr}}

\def\stitle#1{\slidetitle{\red #1}\vspace{-0pt}}

\def\itemtrig{$\vartriangleright$}
\def\itemcirc{$\circ$}
\def\itemT{\item[\itemtrig]}
\def\itemC{\item[$\circ$]}

\everymath={\blue}
\everydisplay={\blue}

\renewcommand{\For}{\textbf{\blue para} }
\renewcommand{\To}{\textbf{\blue até} }
\renewcommand{\Do}{\>\>\textbf{\blue faça}\hspace*{-0.7em}\'\addtocounter{indent}{1}}
\renewcommand{\While}{\textbf{\blue enquanto} }
\renewcommand{\If}{\textbf{\blue se} }
\renewcommand{\Then}{\>\textbf{\blue então}\>\hspace*{0.5em}\addtocounter{indent}{1}}
\renewcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\>\textbf{\blue senão}\>\hspace*{0.5em}\addtocounter{indent}{1}}
\renewcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão se} }
\renewcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão} \addtocounter{indent}{1}}
\renewcommand{\Return}{\textbf{\blue retorne} }


\newcommand{\TITLE}[1]{\item[#1]}

% ugly hack for for/while
\newbox\fixbox

% end of hack
\newcommand{\algcost}[2]{\strut\hfill\makebox[3.5cm][l]{#1}\makebox[4cm][l]{#2}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%Anuschs Extras
%
%\def\enddiscard{}
%\long\def\discard#1\enddiscard{}
%
%%%\vpagecolor{bgblue}
%\hypersetup{pdfpagetransition=Dissolve}
%\hypersetup{pdfpagetransition=R}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Farben kann man hier definieren

\definecolor{bgblue}{rgb}{0.04,0.39,0.53}

\definecolor{darkyellow}{rgb}{0.94,0.820,0.058}
\definecolor{orange}{rgb}{0.95,0.47,0.14}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}

\definecolor{blue2}{rgb}{0.1,0.39,0.53}
\definecolor{yellow1}{rgb}{1,1,0} \definecolor{pink}{rgb}{1,0,1}

\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{lightred2}{rgb}{1,0.7,0.7}
\definecolor{lightred3}{rgb}{1,0.3,0.3}
\definecolor{black}{rgb}{0,0,0} \definecolor{gray1}{rgb}{0.9,0.9,0.9}
\definecolor{red1}{rgb}{1,1,0.9}

\title{Análise e projeto de algoritmos} 
\author{{\blue L.~Takuno} (SENAC)}
\date{{\dgreen 1o. Semestre 2019}} 

%%% Hier beginnt die Praesentation

\begin{document}\def\proofname{{\bf\green Prova.}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Deckblatt
%%%%%%%%%%%%%%%%%%%\usepackage{clrscode3e}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\maketitle

%\slidesubhead{}  %% Teilvortrags-Titel (hier noch nicht)
                 %% Dieser erscheint spaeter oben links unter
                 %% dem ASZ Gesamt-Titel

%%%%%%%%%%%%%%%%%%%%%%% TOC %%%%%%%%%%%%%%%%%%

%\slidesubhead{Outline!!!}

\begin{slide}
  \stitle{Fontes principais}
  \begin{enumerate}\makeatletter\itemsep\z@\makeatother
  \item Cormem T. H.; Leiserson C. E.; Rivest R.: Stein C.. \textit{Introduction to Algorithms}, $3^a$ edição, MIT Press, 2009
  \item Análise de algoritmo - IME/USP (prof. Paulo Feofiloff)
    \verb|http://www.ime.usp.br/~pf/analise_de_algoritmos| 
	
  \end{enumerate}
  \end{slide}
 


\begin{slide}
  \stitle{Princípio de indução matemática}
\end{slide}
 
\begin{slide}
  \stitle{$1^o$ princípio de indução matemática (fraco)}
	
	A prova de uma afirmação por indução matemática é feita em dois passos:
	
	
	\vspace{-1cm} \itemtrig\ (1) Passo base: É provado $P(n_0)$ é verdade para um dado específico.
	
	\vspace{-1cm} \itemtrig\ (2) Passo indutivo: É provado para todos os valores $k \geq n_0$, se $P(k)$ é verdade então $P(k+1)$ é verdade.
	
\begin{center}
\includegraphics[width=0.90\textwidth]{fig01.eps}
\end{center} 
	
\end{slide}
 


\begin{slide}
  \stitle{$2^o$ princípio de indução matemática (forte)}	
  Seja $P(n)$ um predicado que é definido para o inteiro $n$, e seja $a$ e $b$ inteiros fixos, com $a \leq b$. 
  
  A prova de $P(n)$ consiste em verificar a veracidade das seguintes afirmações:
  
  \vspace{-1cm} \itemtrig\ (1) $P(a),P(a+1), \cdots, P(b)$ são verdades (Passo base)
  
  \vspace{-1cm} \itemtrig\ (2) Para qualquer $k \geq b$, se $P(i)$ é verdade para $a \leq i < k $, então $P(k)$ é verdade (Passo indutivo).
  
  \begin{center}
\includegraphics[width=0.90\textwidth]{fig02.eps}
\end{center} 
\end{slide}
 


\begin{slide}
  \stitle{Corretude de algoritmos iterativos}	
\end{slide}
 


\begin{slide}
  \stitle{Corretude de algoritmos iterativos}	
  
  \begin{definition}
  Um \textbf{invariante} de um laço é uma propriedade que relaciona várias variáveis de um algoritmo a cada execução completa daquele laço. 
  \end{definition}
\end{slide}
 


\begin{slide}
  \stitle{Corretude de algoritmos iterativos}	
Estratégia ``típica'' para mostrar a corretude de um algoritmo iterativo através de invariantes:

  \itemtrig\ (1) Mostre que o invariante vale no início da primeira iteração (trivial, em geral).

  \vspace{-1cm} \itemtrig\ (2) Suponha que o invariante vale no início de uma iteração qualquer e prove que ele vale no início da próxima iteração.
  
\end{slide}
 


\begin{slide}
  \stitle{Corretude de algoritmos iterativos}	

  
  \vspace{-1cm} \itemtrig\ (3) Conclua se o algoritmo pára e o invariante vale no início da última iteração, então o algoritmo está \textbf{correto}.
 
 Note que (1) e (2) implicam que o invariante vale no início de qualquer iteração do algoritmo. Isto corresponde ao método de \textbf{indução matemática}.

  
\end{slide}

\begin{slide}
  \stitle{Algoritmo para somar n elementos}

\begin{codebox}
\Procname{$\proc{Soma-Vetor}(A, n)$}
\li $\id{s} \gets 0$
\li \For $\id{j} \gets 1$ \To $\id{n}$
\li \Do $\id{s} \gets s + A[j]$
\End
\li \Return $\id{s}$
\end{codebox}

Corretude do algoritmo. Invariante na linha 2.

\vspace{-1cm} \itemtrig\ No início de cada iteração $j$, $s$ contém a soma dos elementos da posição $1$ até $j-1$, portanto vale que $\displaystyle s = \sum_{i=1}^{j-1}A[i]$

\end{slide}

\begin{slide}
  \stitle{Algoritmo para somar n elementos}

Corretude do algoritmo. Invariante na linha 2.

 \itemtrig\ Na primeira iteração temos que $j=1$ e portanto $\displaystyle s = 0 = \sum_{i=1}^{0}A[i]$. Ou seja o invariante vale.

\end{slide}

\begin{slide}
  \stitle{Algoritmo para somar n elementos}

Corretude do algoritmo. Invariante na linha 2.

 \itemtrig\ Suponha que no início da iteração $j$ o invariante vale, ou seja, $\displaystyle s =  \sum_{i=1}^{j-1}A[i]$. 
 
 Então o algoritmo adiciona $A[j]$ a $s$ e portanto, no início da iteração $j+1$ temos que $\displaystyle s =  \sum_{i=1}^{j}A[i]$. Este é exatamente o invariante na iteração $j+1$

\end{slide}

\begin{slide}
  \stitle{Algoritmo para somar n elementos}
  Na última iteração temos que $j = n + 1$ (laço pára) e a correção do algoritmo é evidente, pois o invariante diz que 
  
  $$\displaystyle s =  \sum_{i=1}^{n}A[i]$$
\end{slide}

\begin{slide}
  \stitle{Algoritmo para calcular o fatorial de n}
\end{slide}

\begin{slide}
  \stitle{Algoritmo para calcular o fatorial de n}

\begin{codebox}
\Procname{$\proc{Fatorial}(n)$}
\li $\id{fat} \gets 1$
\li $\id{i} \gets 1$
\li \While $(\id{i} \leq n)$
\li \Do $\id{fat} \gets \id{fat} * \id{i}$
\li $\id{i} \gets \id{i} + 1$
\End
\li \Return $\id{fat}$
\end{codebox}

Qual é o invariante na linha 3?
  
\end{slide}

\begin{slide}
  

\begin{codebox}
\Procname{$\proc{Fatorial}(n)$}
\li $\id{fat} \gets 1$
\li $\id{i} \gets 1$
\li \While $(\id{i} \leq n)$
\li \Do $\id{fat} \gets \id{fat} * \id{i}$
\li $\id{i} \gets \id{i} + 1$
\End
\li \Return $\id{fat}$
\end{codebox}

Qual é o invariante na linha 3?
  
Invariante: $\displaystyle fat = \prod_{k=1}^{i-1} k$  
  
No início de cada iteração $i$, $fat$ contém o valor calculado do fatorial de $1$ até $i-1$.  
\end{slide}


\begin{slide}
  \stitle{Algoritmo para calcular o fatorial de n}
  
\itemtrig\  Início  
  
Antes do início do laço $i = 1$, assim, $fat = 1$. Isto mostra que o invariante está correto no início da primeira iteração.
\end{slide}


\begin{slide}
  \stitle{Algoritmo para calcular o fatorial de n}
  
\itemtrig\  Invariância (durante a execução do laço)

Suponha que o invariante está correto no início da iteração $i$, isto é, $\displaystyle fat = \prod_{k=1}^{i-1} k$.

O algoritmo multiplica este valor por $i$, obtendo $\displaystyle \prod_{k=1}^{i} k$, e logo após incrementa $i$ de $1$. Portanto, isto mostra que depois da iteração o invariante se mantém.
\end{slide}


\begin{slide}
  \stitle{Algoritmo para calcular o fatorial de n}
  
\itemtrig\  Término

O laço termina quando $i > n$, isto é, $i = n + 1$. Substituindo $i$ por $n+1$ no invariante, temos que:

$$\displaystyle fat = \prod_{k=1}^{n} k = 1 * 2 * \cdots * n = n!$$
 
 Portanto, o algoritmo está correto. 
\end{slide}

\begin{slide}
  \stitle{Laços aninhados}
\end{slide}

\begin{slide}
  \stitle{Laços aninhados}
  \itemtrig\  Analisar um laço por vez começando pelo mais interno.
  
 \vspace{-1cm} \itemtrig\  Para cada laço, determinar um invariante.
 
 \vspace{-1cm} \itemtrig\  Provar que o invariante é válido.
 
 \vspace{-1cm} \itemtrig\  Mostrar que o algoritmo termina.
 
 \vspace{-1cm} \itemtrig\  Usar o invariante para provar que o algoritmo retorna o valor desejado.   
\end{slide}

\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
\end{slide}

\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
\begin{codebox}
\Procname{$\proc{Insertion-Sort}(A, n)$}
\li \For $j \gets 2$ \To $\id{n}$
\li \Do
$\id{chave} \gets A[j]$
\li \Comment Insere $A[j]$ na sequência ordenada
$A[1 \twodots j-1]$.
\li $i \gets j-1$
\li \While $i > 0$ \textbf{\blue e} $A[i] > \id{chave}$
\li \Do
$A[i+1] \gets A[i]$
\li $i \gets i-1$
\End
\li $A[i+1] \gets \id{chave}$
\End
\end{codebox}  
\end{slide}


\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
   \itemtrig\  Invariante principal ($i_1$):
   
   No começo de cada iteração do laço da linha (1) o subvetor $A[1 .. j-1]$ está ordenado. 
\begin{center}   
\begin{tabular}{ccccccccccc}
1                        &                         &                         &                         &                         &                         & j                       &                         &                         &                         & n                       \\ \hline
\multicolumn{1}{|c|}{20} & \multicolumn{1}{c|}{25} & \multicolumn{1}{c|}{35} & \multicolumn{1}{c|}{40} & \multicolumn{1}{c|}{44} & \multicolumn{1}{c|}{55} & \multicolumn{1}{c|}{\red 38} & \multicolumn{1}{c|}{\black 99} & \multicolumn{1}{c|}{\black 10} & \multicolumn{1}{c|}{\black 65} & \multicolumn{1}{c|}{\black 50} \\ \hline
\end{tabular}
\end{center}

\itemcirc\ Suponha que o invariante é válido. 

\vspace{-1cm} \itemcirc\ Então a corretude do algoritmo é ``evidente''.

\vspace{-1cm} \itemcirc\ No início da última iteração temos $j=n+1$. Assim, do invariante segue que o subvetor $A[1 .. n]$ está ordenado. 
\end{slide}


\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
   \itemtrig\  Invariantes auxiliares:
   
   No início da linha 5 valem os seguintes invariantes:
   
   ($i_2$): $A[1 .. i]$ e $A[i+2 .. j]$ contém elementos de $A[1 .. j]$ antes de entrar no laço da linha 5.

\vspace{-1cm} ($i_3$): $A[1 .. i]$ e $A[i+2 .. j]$ são crescentes

\vspace{-1cm} ($i_4$): $A[1 .. i]$ $\leq$ $A[i+2 .. j]$ 

\vspace{-1cm} ($i_5$): $A[i+2 .. j] > chave$ 
\end{slide}


\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
 Invariante forte ($i_1'$):
 
 No começo de cada iteração do laço da linha 1, o subvetor $A[1..j-1]$ é uma permutação ordenada do subvetor original $A[1 .. j-1]$.
 
 
\begin{tabular}{l}
\black Invariantes ($i_2$) a ($i_5$) \\ 
\black + condição de parada na linha 5 \\
\black + atribuição da linha 7.  
\end{tabular}   $\Bigg\} \Longrightarrow$ ($i_1'$)


\end{slide}


\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
Esboço da demonstração de ($i_1'$):

Validade na primeira iteração: neste caso, temos $j=2$ e o invariante simplesmente afirma que $A[1..1]$ está ordenado, o que é óbvio.
 
\end{slide}

\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}
Validade na iteração $j>2$: segue da discussão anterior, os elementos maiores que a chave são ``empurrados'' para seus lugares corretos  e a chave é colocada no ``espaço vazio''. 

Mas, uma demonstração mais formal deste fato exigiria uma prova dos invariantes auxiliares do laço interno.
\end{slide}

\begin{slide}
  \stitle{Análise do algoritmo: Insertion sort}

Na última iteração: temos $j = n + 1$ e logo $A[1..n]$ está ordenado.

Portanto, o algoritmo está correto.
\end{slide}

\begin{slide}
  \stitle{Corretude de algoritmos recursivos}
\end{slide}

\begin{slide}
  \stitle{Corretude de algoritmos recursivos}
  
  Em muitos problemas computacionais cada solução de uma instância do problema contém soluções de instâncias menores.
  
 Por exemplo: Divisão e conquista.
\end{slide}

\begin{slide}
  \stitle{Corretude de algoritmos recursivos}

Corretude provada na indução:

\itemcirc\ Passo base é a base da recursão

\itemcirc\ Assumir que as chamadas recursivas estão corretas, e usar tal argumento para provar que a execução corrente está correta (passo indutivo)

\end{slide}


\begin{slide}
  \stitle{Algoritmo recursivo para somar n elementos}
\end{slide}

\begin{slide}
  \stitle{Algoritmo recursivo para somar n elementos}
\begin{codebox}
\Procname{$\proc{Soma-Vetor}(A, n)$}
\li \If $\id{n} = 0$
\li \Then $\id{s} \gets 0$
\li \Else $\id{s} \gets \proc{Soma-Vetor}(A, n-1) + A[n]$
\End
\li \Return $\id{s}$
\end{codebox}
Vamos provar a corretude por indução.
\end{slide}

\begin{slide}
  \stitle{Algoritmo recursivo para somar n elementos}
  
\begin{itemize}
\item Passo base:

$n = 0$ (vetor sem nenhum elemento), $s = 0$ (trivial)

\item Passo indutivo:

\textbf{Hipótese}: Assumimos que a chamada $\proc{Soma-Vetor}(A, n-1)$ está correta.  Se $\proc{Soma-Vetor}(A, n-1)$ está correto, então para todo $n>0$ o algoritmo retornará a soma dos $n-1$ elementos mais $A[n]$. 
\end{itemize}  

Portanto, o algoritmo está correto.
\end{slide}

\begin{slide}
  \stitle{Algoritmo recursivo de Fibonacci}
\end{slide}

\begin{slide}
  \stitle{Algoritmo recursivo de Fibonacci}
\begin{codebox}
\Procname{$\proc{Fib}(n)$}
\li \If $\id{n} \leq 1$
\li \Then \Return $\id{n}$
\li \Else \Return $\proc{Fib}(n-1) + \proc{Fib}(n-2)$
\End
\end{codebox}  
Vamos provar a corretude por indução.
\end{slide}


\begin{slide}
  \stitle{Algoritmo recursivo de Fibonacci}
  

\vspace{-1.0cm}\begin{itemize}
\item Passo base:

Para $n = 0$ temos $\proc{Fib}(0) = 0$.

\vspace{-0.5cm} Para $n = 1$ temos $\proc{Fib}(1) = 1$.


\item Passo indutivo:

\textbf{Hipótese}: Para $n \geq 2$ e para todo $0 \leq m < n$, as chamadas de  $\proc{Fib}(n-1)$ e $\proc{Fib}(n-2)$ estão corretas.

Assim temos:

 $\displaystyle \proc{Fib}(n-1) + \proc{Fib}(n-2) \underset{def}{\overset{hip}{=}} \proc{Fib}(n)$
 
 Portanto, o algoritmo está correto.
\end{itemize} 
\end{slide}


\begin{slide}
  \stitle{Obrigado}
\end{slide}

\end{document}

% Local Variables: 
% mode: latex
% eval: (Portug-mode)
% TeX-master: t
% End: 
