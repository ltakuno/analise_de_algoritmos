\documentclass{article}

\usepackage[brazil]{babel}     % Definição-padrão língua portuguesa
\usepackage[latin1]{inputenc}  % Para traduzir acentos
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{float}

\usepackage{clrscode}

\usepackage{amsmath,amssymb,amsthm} \usepackage{amsfonts}
\usepackage[colorlinks,backref]{hyperref}

\setlength{\topmargin}{-0.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{-.125in}
\setlength{\evensidemargin}{-.125in}
\setlength{\textwidth}{6.75in}


\newcommand{\CWEB}{\texttt{CWEB} }
\newtheorem{definicao}{Definição}[section]
\newtheorem{exemplo}{Exemplo}[section]
\newtheorem{teorema}{Teorema}[section]
\newtheorem{corolario}{Corolário}[section]

\def\red{\color[rgb]{0.7,0,0}}
\def\green{\color[rgb]{0,.8,0}}
\def\darkgreen{\color[rgb]{0.1,0.4,0.0}}
\let\dgreen\darkgreen
\def\blue{\color[rgb]{0,0,.8}}
\def\yellow{\color[rgb]{1,1,0}}
\def\black{\color[rgb]{0,0,0}}

\def\pink{\color[rgb]{1,0,1}}
\def\brown{\color[rgb]{.5,.1,.3}}
\def\lilaz{\color[rgb]{.5,0,.5}}
\def\hmmm{\color[rgb]{.3,.1,.5}}
\def\magenta{\color[rgb]{.6,.05,.05}}

\newcommand{\uc}[1]{\centerline{\underline{#1}}}
\newcommand{\pic}[1]{\fbox{picture:{#1}}}
%\renewcommand{\bf}{\mbox{}}
\newcommand{\cP}{{\cal P}} \newcommand{\cT}{{\cal T}}
\newcommand{\add}{\mbox{\rm add}} \newcommand{\pr}{\mbox{\rm Pr}}

\def\stitle#1{\slidetitle{\red #1}\vspace{-0pt}}
\everymath={\blue}
\everydisplay={\blue}

\def\itemtrig{$\vartriangleright$}
\def\itemcirc{$\circ$}
\def\itemT{\item[\itemtrig]}
\def\itemC{\item[$\circ$]}

\renewcommand{\For}{\textbf{\blue for} }
\renewcommand{\To}{\textbf{\blue to} }
\renewcommand{\Do}{\>\>\textbf{\blue do}\hspace*{-0.7em}\'\addtocounter{indent}{1}}
\renewcommand{\While}{\textbf{\blue while} }
\renewcommand{\If}{\textbf{\blue if} }
\renewcommand{\Then}{\>\textbf{\blue then}\>\addtocounter{indent}{1}}
\renewcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\>\textbf{\blue else}\>\addtocounter{indent}{1}}
\renewcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue elseif} }
\renewcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue else} \addtocounter{indent}{1}}
\renewcommand{\Return}{\textbf{\blue return} }



\begin{document}


\bibliographystyle{plain}       % estilo de bibliografia

\title{Centro Universitário Senac\\ Bacharelado em Ciência da Computação \\ Análise e projeto de algoritmos - ADO 01}
\author{Professor: Leonardo Takuno \\
\texttt{\{leonardo.takuno@gmail.com\}}}
\maketitle

\begin{enumerate}
\item Analise a complexidade de algoritmos iterativos a seguir. Para cada item, expresse a complexidade em termos de notação O, justifique a sua resposta:

\begin{enumerate}
\item[(a)] 
\begin{verbatim}
soma = 0;
for(i = 1; i <= n; i++)
   for(j = 1; j <= i; j++)
      soma++;
\end{verbatim}

\item[(b)] 
\begin{verbatim}
soma = 0;
for(i = 1; i <= n; i++)
   for(j = i; j <= n; j++)
      for(k = 1; k <= 100; k++)
         soma++;
\end{verbatim}

\item[(c)] 
\begin{verbatim}
soma = 0;
for(i = n/2; i <= n; i++)
   for(j = i; j <= n/2; j++)
      for(k = 1; k <= n; k *= 2)
         soma++;
\end{verbatim}

\item[(d)] 
\begin{verbatim}
soma = 0;
for(i = n/2; i <= n; i++)
   for(j = i; j <= n; j *= 2)
      for(k = 1; k <= n; k *= 2)
         soma++;
\end{verbatim}

\item[(e)] 
\begin{verbatim}
soma = 0;
for(i = n*n; i <= n*n*n; i++)
   soma++;
\end{verbatim}

\end{enumerate}


\item Considere o \textbf{problema de busca}:

\textbf{Entrada:} Uma sequência de $n$ números $\langle a_1, a_2, \cdots, a_n \rangle$ e um valor $v$.

\textbf{Saída:} Um índice $i$ tal que $v = A[i]$ e $1 \leq i \leq n$, ou uma valor $-1$ se $v$ não aparece em A.

Escreva o pseudocódigo para a busca linear que busca $v$ dentro da sequência.

\item Voltando ao problema de busca, observe que se a sequência $A$ está ordenada, nós podemos comparar o meio da sequência com $v$ e eliminar metade da sequência da busca. O algoritmo de \textbf{busca binária} repete este procedimento, dividindo ao meio a porção restante da sequência a cada passo. Escreva um pseudocódigo, ou iterativo ou recursivo, para a busca binária. Argumente que o tempo de execução de pior caso da busca binária é $O(\lg n)$


\item Considere a ordenação de $n$ números armazenados em um vetor $A$ utilizando a seguinte técnica: encontrar o menor elemento de $A$ e trocá-lo com o primeiro elemento de $A$; então, encontrar o segundo menor elemento de $A$ e trocá-lo com o segundo elemento de $A$; continuar dessa maneira até que os $n$ elementos de $A$ estejam ordenados. Escreva um pseudocódigo para este algoritmo, que é conhecido como \textbf{ordenação por seleção}. Forneça o tempo de execução do melhor e do pior caso da ordenação por seleção na notação $\theta$.

\item Considere o algoritmo $\proc{Insertion-Sort}(A)$ a seguir:

\begin{codebox}
\Procname{$\proc{Insertion-Sort}(A)$}
\li \For $j \gets 2$ \To $\id{length}[A]$
\li \Do
$\id{chave} \gets A[j]$
\li \Comment Inserir $A[j]$ na sequência ordenada $A[1 \twodots j-1]$.
\li $i \gets j-1$
\li \While $i > 0$ and $A[i] > \id{chave}$
\li \Do
$A[i+1] \gets A[i]$
\li $i \gets i-1$
\End
\li $A[i+1] \gets \id{chave}$
\End
\end{codebox}

Observe que o laço \textbf{enquanto} das linhas $5-7$ do procedimento $\proc{Insertion-Sort}$ utiliza uma busca linear (da direita para esquerda) no vetor $A[1 \twodots j - 1]$. Será que, ao invés da busca linear, poderíamos utilizar uma busca binária para melhor o tempo de execução do pior caso da ordenação por inserção para $\theta(n \lg n)$?
 
\end{enumerate}
\end{document}
