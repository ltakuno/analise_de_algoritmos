%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% talk: prototype
%%% 2002/10/16
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% Erstellen eines Vortrags in PDF-Format wie folgt:
%%%
%%% 1) Uebersetzen der Datei mit 
%%%    pdflatex asz
%%% 2) Wenn Features von ppower4 gewuenscht werden, dann die eben
%%%    entstandene Datei asz.pdf weiterverarbeiten mit
%%%    ./ppower4 asz.pdf vortrag.pdf
%%% 3) Die Datei vortrag.pdf kann nun mit dem Acrobat Reader angesehen
%%%    werden
%%%
%%% Fuer Testzwecke ist auch ein "normales" Uebersetzen mit LaTeX
%%% moeglich:
%%% 1) latex asz
%%% 2) dvips asz.dvi -o asz.ps -t a4 -t landscape
%%% 3) Anschauen mit ghostview
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifx\pdfoutput\undefined \documentclass[clock,landscape]{slides} \else
\documentclass[clock,landscape]{slides} \fi
%\documentclass[clock,pdftex,landscape]{slides} \fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Escrevendo em português:
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc} % isso é quase redundante
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{psfrag}
 

\usepackage{multicol}

\usepackage{clrscode}
%----------------------------
\usepackage{tabularx}
%%% Die Datei mit dem ASZ-Layout

\usepackage{shi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath,amssymb,amsthm} \usepackage{amsfonts}
\usepackage[colorlinks,backref]{hyperref}
%\usepackage{background}

%\usepackage{picinpar}

\hypersetup{pdftitle={Análise e projeto de algoritmos},
  pdfsubject={Análise de algoritmos}, 
  pdfauthor={Leonardo Takuno, Centro Universitário SENAC, 
  <leonardo.takuno@gmail.com>},
  pdfkeywords={acrobat, ppower4},
%  pdfpagemode={FullScreen},
  colorlinks={false},
  linkcolor={red}
}

\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Pauseneffekte mit ppower4 werden moeglich

\usepackage{pause}
\newcommand\plone{\pause\pauselevel{=1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheoremstyle{mythm}% name
  {40pt}%      Space above
  {-15pt}%      Space below
  {\sf\itshape\blue}%      Body font
  {}%         Indent amount (empty = no indent, \parindent = para indent)
  {\sf\bfseries\green}% Thm head \vspacefont
  {.}%        Punctuation after thm head
  { }%     Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%         Thm head spec (can be left empty, meaning `normal')

\theoremstyle{mythm}
\newtheorem{theorem}             {Theorem}       
\newtheorem{claim}     [theorem] {Claim}         
\newtheorem{lemma}     [theorem] {Lemma}         
\newtheorem{corollary} [theorem] {Corollary}     
\newtheorem{fact}      [theorem] {Fact}          
\newtheorem{conjecture}[theorem] {Conjecture}    

\newtheorem{problem}   [theorem] {Problema}       
\newtheorem{propriedade}  [theorem] {Propriedade}       
\newtheorem{corolario}  [theorem] {Corolário}       
\newtheorem{definition}   [theorem] {Definição}       

%%% Symbole

\newcommand{\NN}{\mathbb{N}} \newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}} \newcommand{\1}{{{\mathchoice {\rm
        1\mskip-4mu l} {\rm 1\mskip-4mu l} {\rm 1\mskip-4.5mu l} {\rm
        1\mskip-5mu l}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\let\phi\varphi
\let\epsilon\varepsilon
\let\rho\varrho
\let\tilde\widetilde
\let\approx\thickapprox
\let\sim\thicksim

\def\({\left(}
\def\){\right)}
\def\[{\left[}
\def\]{\right]}
\def\<{\langle}
\def\>{\rangle}
\let\:\colon
\def\llfloor{\left\lfloor}
\def\rrfloor{\right\rfloor}
\def\llceil{\left\lceil}
\def\rrceil{\right\rceil}

%%% Textmakros
\def\ex{\mathop{\text{\rm ex}}\nolimits} 
\def\cB{{\mathcal B}} 
\def\cG{{\mathcal G}}
\def\cS{{\mathcal S}} 
\def\cW{{\mathcal W}} 
\def\cQ{{\mathcal Q}} 
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}} 
\def\GG{{\mathbb G}} 
\def\e{{\rm e}}
\def\epsilon{{\varepsilon}} 
\def\DISC{\mathop{\textrm{\rm DISC}}\nolimits} 
\def\EIG{\mathop{\textrm{\rm EIG}}\nolimits}
\def\CIRCUIT{\mathop{\textrm{\rm CIRCUIT}}\nolimits}
\def\CYCLE{\mathop{\textrm{\rm CYCLE}}\nolimits}
\def\SUB{\mathop{\textrm{\rm SUB}}\nolimits}
\def\NSUB{\mathop{\textrm{\rm NSUB}}\nolimits}
\def\PAIR{\mathop{\textrm{\rm PAIR}}\nolimits}
\def\TFNSUB{\mathop{\textrm{\rm TFNSUB}}\nolimits}
\def\BDD{\mathop{\textrm{\rm BDD}}\nolimits}
\def\eps{\varepsilon}

\def\rmd{\text{\rm d}}
\def\wtc{\widetilde{c}\,}
\def\whc{\widehat{c}}
\def\bfb{{\bf b}}
\def\bff{{\bf f}}
\def\bft{{\bf t}}
\def\bfx{{\bf x}}
\def\bfz{{\bf z}}
\def\cB{{\mathcal B}}
\def\cD{{\mathcal D}}
\def\cG{{\mathcal G}}
\def\cM{{\mathcal M}}
\def\cN{{\mathcal N}}
\def\cR{{\mathcal R}}
\def\cS{{\mathcal S}}
\def\cW{{\mathcal W}}
\def\PP{{\mathbb P}}
\def\EE{{\mathbb E}}
\def\FF{{\mathbb F}}
\def\NN{{\mathbb N}}
\def\RR{{\mathbb R}}
\def\ZZ{{\mathbb Z}}
\def\e{{\rm e}}
\def\card{\mathop{\text{\rm card}}\nolimits}
\def\rank{\mathop{\text{\rm rank}}\nolimits}
\def\trace{\mathop{\text{\rm trace}}\nolimits}
\def\Ave{\mathop{\text{\rm Ave}}\nolimits}
\def\Bi{\mathop{\text{\rm Bi}}\nolimits}
\def\im{\mathop{\text{\rm im}}\nolimits}
\def\ind{\mathop{\text{\rm ind}}\nolimits}
\def\dist{\mathop{\text{\rm dist}}\nolimits}
\def\nDist{\mathop{\text{\rm \#Dist}}\nolimits}
\let\Dist\nDist
\def\De{D_{\rm e}}
\def\sumL{\sum\nolimits_1}
\def\sumS{\sum\nolimits_2}
\def\GF{\mathop{\text{\rm GF}}\nolimits}
\let\FF\GF
\def\Bip{\mathop{\text{\rm Bip}}\nolimits}
\def\adj{\mathop{\text{\rm adj}}\nolimits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nx}{{\hfill\vspace*{-2cm}\tiny +}}

%\newcommand{\red}[1]{\textcolor{red}{#1}}
%\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\yellow}[1]{\textcolor{yellow}{#1}}
%\newcommand{\green}[1]{\textcolor{green}{#1}}
%\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\def\red{\color[rgb]{0.7,0,0}}
\def\green{\color[rgb]{0,.8,0}}
\def\darkgreen{\color[rgb]{0.1,0.4,0.0}}
\let\dgreen\darkgreen
\def\blue{\color[rgb]{0,0,.8}}
\def\yellow{\color[rgb]{1,1,0}}
\def\black{\color[rgb]{0,0,0}}

\def\pink{\color[rgb]{1,0,1}}
\def\brown{\color[rgb]{.5,.1,.3}}
\def\lilaz{\color[rgb]{.5,0,.5}}
\def\hmmm{\color[rgb]{.3,.1,.5}}
\def\magenta{\color[rgb]{.6,.05,.05}}

\newcommand{\uc}[1]{\centerline{\underline{#1}}}
\newcommand{\pic}[1]{\fbox{picture:{#1}}}
%\renewcommand{\bf}{\mbox{}}
\newcommand{\cP}{{\cal P}} \newcommand{\cT}{{\cal T}}
\newcommand{\add}{\mbox{\rm add}} \newcommand{\pr}{\mbox{\rm Pr}}

\def\stitle#1{\slidetitle{\red #1}\vspace{-0pt}}

\def\itemtrig{$\vartriangleright$}
\def\itemcirc{$\circ$}
\def\itemT{\item[\itemtrig]}
\def\itemC{\item[$\circ$]}

\everymath={\blue}
\everydisplay={\blue}

\renewcommand{\For}{\textbf{\blue para} }
\renewcommand{\To}{\textbf{\blue até} }
\renewcommand{\Do}{\>\>\textbf{\blue faça}\hspace*{-0.7em}\'\addtocounter{indent}{1}}
\renewcommand{\While}{\textbf{\blue enquanto} }
\renewcommand{\If}{\textbf{\blue se} }
\renewcommand{\Then}{\>\textbf{\blue então}\>\hspace*{0.5em}\addtocounter{indent}{1}}
\renewcommand{\Else}{\kill\addtocounter{indent}{-1}\liprint\>\textbf{\blue senão}\>\hspace*{0.5em}\addtocounter{indent}{1}}
\renewcommand{\ElseIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão se} }
\renewcommand{\ElseNoIf}{\kill\addtocounter{indent}{-1}\liprint\textbf{\blue senão} \addtocounter{indent}{1}}
\renewcommand{\Return}{\textbf{\blue retorne} }


\newcommand{\TITLE}[1]{\item[#1]}

% ugly hack for for/while
\newbox\fixbox

% end of hack
\newcommand{\algcost}[2]{\strut\hfill\makebox[3.5cm][l]{#1}\makebox[4cm][l]{#2}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%Anuschs Extras
%
%\def\enddiscard{}
%\long\def\discard#1\enddiscard{}
%
%%%\vpagecolor{bgblue}
%\hypersetup{pdfpagetransition=Dissolve}
%\hypersetup{pdfpagetransition=R}
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Farben kann man hier definieren

\definecolor{bgblue}{rgb}{0.04,0.39,0.53}

\definecolor{darkyellow}{rgb}{0.94,0.820,0.058}
\definecolor{orange}{rgb}{0.95,0.47,0.14}
\definecolor{darkgreen}{rgb}{0.0,0.5,0.0}

\definecolor{blue2}{rgb}{0.1,0.39,0.53}
\definecolor{yellow1}{rgb}{1,1,0} \definecolor{pink}{rgb}{1,0,1}

\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{lightred2}{rgb}{1,0.7,0.7}
\definecolor{lightred3}{rgb}{1,0.3,0.3}
\definecolor{black}{rgb}{0,0,0} \definecolor{gray1}{rgb}{0.9,0.9,0.9}
\definecolor{red1}{rgb}{1,1,0.9}

\title{Análise e projeto de algoritmos} 
\author{{\blue L.~Takuno} (SENAC)}
\date{{\dgreen 1o. Semestre 2019}} 

%%% Hier beginnt die Praesentation

\begin{document}\def\proofname{{\bf\green Prova.}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Deckblatt
%%%%%%%%%%%%%%%%%%%\usepackage{clrscode3e}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\maketitle

%\slidesubhead{}  %% Teilvortrags-Titel (hier noch nicht)
                 %% Dieser erscheint spaeter oben links unter
                 %% dem ASZ Gesamt-Titel

%%%%%%%%%%%%%%%%%%%%%%% TOC %%%%%%%%%%%%%%%%%%

%\slidesubhead{Outline!!!}

\begin{slide}
  \stitle{Fontes principais}
  \begin{enumerate}\makeatletter\itemsep\z@\makeatother
  \item Cormem T. H.; Leiserson C. E.; Rivest R.: Stein C.. \textit{Introduction to Algorithms}, $3^a$ edição, MIT Press, 2009
  \item Análise de algoritmo - IME/USP (prof. Paulo Feofiloff)
    \verb|http://www.ime.usp.br/~pf/analise_de_algoritmos| 
	
  \end{enumerate}
  \end{slide}
 
 
\begin{slide}
  \stitle{Limite inferior para ordenação}  
\end{slide}

\begin{slide}
  \stitle{Limite inferior para ordenação}  
  Um algoritmo de ordenação baseia-se em comparações se o fluxo do algoritmo para uma entrada de tamanho $n$ depende apenas de comparações do tipo $a_i \leq a_j$. Todos os algoritmos de ordenação que estudamos até o momento baseiam-se em comparações.
\end{slide}
 
\begin{slide}
  \stitle{Limite inferior para ordenação}  
  
\begin{theorem}
Qualquer algoritmo de ordenação por comparação exige $\Omega(n \lg n)$ comparações no pior caso. 
\end{theorem}  
\textbf{Dem.:} Por árvore de decisão.
 
\begin{center}
\includegraphics[width=.6\textwidth]{fig01}
\end{center}
\end{slide}
 
\begin{slide}
  \stitle{Limite inferior para ordenação}  
  
  Dado um vetor com n elementos, o vetor ordenado pode ser qualquer uma das $n!$ permutações.
  
  Um algoritmo de ordenação efetua um número de comparações equivalente a altura da árvore com $n!$ folhas.
  
  Uma árvore binária com altura $h$ tem no máximo $2^h$ folhas. 
\end{slide}
 
\begin{slide}
  \stitle{Limite inferior para ordenação}  
  Logo, temos:
  
  $\begin{array}{l}
    n! \leq 2^h \Rightarrow \lg(n!) \leq h \quad (a \leq b \Rightarrow \lg a \leq \lg b)\\
    h \geq \lg(n!) \Rightarrow h = \Omega(n \lg n)\\
    \lg(n!) \geq \displaystyle \frac{n}{4} \lg n, n \geq 16
  \end{array} $ 
  
  Portanto, $h = \Omega(n \lg n)$
  \end{slide}
 
\begin{slide}
  \stitle{Ordenação em tempo linear}  
\end{slide}
 
\begin{slide}
  \stitle{Algoritmo Counting Sort}  

Cada elemento é um inteiro i no intervalo $[1..k]$

\vspace{-1cm}Idéia:
\begin{itemize}
\vspace{-1cm}\item[\itemtrig] Contar para cada elemento $x$ da entrada o número de elementos menores que $x$.
\vspace{-1cm}\item[\itemtrig] Colocar $x$ diretamente na usa posição no vetor de saída.
\end{itemize}
Utiliza dois vetores auxiliares para ordenar.
\end{slide}
 
\begin{slide}
  \stitle{Algoritmo Counting Sort}  
$\proc{Counting-Sort}(A, B, n, k)$
\vspace{-2.0cm}
\begin{tabbing}
~~~~ \= ~~~~\= ~~~~\= ~~~~\= ~~~~~~~\= \hspace*{12cm}                               \= custo \\
1  \> \For $i = 1$ \To  $k$  \textbf{\blue faça}\> \> \> \> \> $\Theta(k)$ \\
2  \> \>  $\id{C[i]} = 0$ \> \> \> \>  $\Theta(k)$  \\
3  \> \For $j = 1$ \To $n$ \textbf{\blue faça} \> \> \>\>\> $\Theta(n)$   \\
4  \> \>  $C[A[i]] = C[A[i]] + 1$ \>   \> \>\>  $\Theta(n)$  \\
5  \> $\vartriangleright$ C[i] contém núm. de elementos iguais a i  \> \>   \>   \\
6  \> \For $i = 2$ \To  $k$  \textbf{\blue faça}\> \> \> \> \>  $\Theta(k)$   \\
7  \> \>  $C[i] = C[i] + C[i-1]$  \> \>  \> \>  $\Theta(k)$\\
8  \> $\vartriangleright$ C[i] contém núm. de elementos $\leq$ i  \> \> \>\\   
9  \> \For $j = n$ \To  $1$  \textbf{\blue faça}\> \>  \>\>\> $\Theta(n)$   \\
10 \> \> $B[C[A[j]]] = A[j]$  \> \> \>\>  $\Theta(n)$  \\
11 \> \> $C[A[j]] = C[A[j]] - 1$ \> \>  \>\>  $\Theta(n)$  \\
\end{tabbing}  
\end{slide}
 
\begin{slide}
  \stitle{Algoritmo Counting Sort}  
  Entrada:
  
\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
A & 2 & 5 & 3 & 0 & 2 & 3 & 0 & 5 & 3 & 0 \\ \cline{2-11} 
\end{tabular}

\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
B & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ \\ \cline{2-11} 
\end{tabular}

Saída:

\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
B & 0 & 0 & 0 & 2 & 2 & 3 & 3 & 3 & 5 & 5 \\ \cline{2-11} 
\end{tabular}

Estão na mesma ordem em que aparece em A.
\end{slide}
 
\begin{slide}
  \stitle{Algoritmo Counting Sort}  
  Passo a passo:
  
\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
A & 2 & 5 & 3 & 0 & 2 & 3 & 0 & 5 & 3 & 0 \\ \cline{2-11} 
\end{tabular}

\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
B & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ \\ \cline{2-11} 
\end{tabular}


\begin{tabular}{ccccccc}
 $\hspace{0.7cm}$ & 0 & 1 & 2 & 3 & 4 & 5  \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|}
\cline{2-7}
C & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$ & $\hspace{0.45cm}$   \\ \cline{2-7} 
\end{tabular}
  
  Atividade: "Simular" a aplicação do algoritmo Counting-Sort.
\end{slide}

\begin{slide}
  \stitle{Algoritmo Counting Sort}  
  Passo a passo:
  
\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
A & 2 & 5 & 3 & 0 & 2 & 3 & 0 & 5 & 3 & 0 \\ \cline{2-11} 
\end{tabular}

\begin{tabular}{ccccccccccc}
 $\hspace{0.7cm}$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
B & 0 & 0 & 0 & 2 & 2 & 3 & 3 & 3 & 5 & 5 \\ \cline{2-11} 
\end{tabular}

\begin{tabular}{ccccccc}
 $\hspace{0.7cm}$ & 0 & 1 & 2 & 3 & 4 & 5  \\ 
\end{tabular}\\  
\begin{tabular}{c|c|c|c|c|c|c|}
\cline{2-7}
C & 0 & 3 & 3 & 5 & 8 & 8   \\ \cline{2-7} 
\end{tabular}
  
  Perceba a estabilidade do algoritmo
\end{slide}
 
\begin{slide}
    \stitle{Classificação dos algoritmos de ordenação}  

Estabilidade

\begin{itemize}
\item[\itemcirc] Um algoritmo é \textbf{estável} se elementos idênticos ocorrem no vetor ordenado na mesma ordem que foram recebidos como entrada
\end{itemize}

Localidade
\begin{itemize}
\item[\itemcirc] Um algoritmo é \textbf{local} se a quantidade de memória adicional requerida é constante.
\end{itemize}

Note que $\proc{Counting Sort}$ é estável mas não local.
\end{slide}
 
 \begin{slide}
Quais são os algoritmos estáveis?

\begin{itemize}
\vspace{-1cm}\itemT $\proc{Insertion-Sort}$ 
\vspace{-1cm}\itemT $\proc{Merge-Sort}$ 
\vspace{-1cm}\itemT $\proc{Bubble-Sort}$ 
\vspace{-1cm}\itemT $\proc{Counting-Sort}$ 
\vspace{-1cm}\itemT $\proc{Bucket-Sort}$ 
\end{itemize}    

Quais não são estáveis?
\begin{itemize}
\vspace{-1cm}\itemT $\proc{Heap-Sort}$ 
\vspace{-1cm}\itemT $\proc{Quick-Sort}$ 
\vspace{-1cm}\itemT $\proc{Selection-Sort}$ (Depende do algoritmo)
\vspace{-1cm}\itemT $\proc{Shell-Sort}$ 
\end{itemize} 
\end{slide}

\begin{slide}
    \stitle{Radix-Sort} 
\end{slide}

\begin{slide}
    \stitle{Radix-Sort}  
    
  \itemtrig\   Números a serem ordenados tem $d$ dígitos
    
  \itemtrig\   Inicia-se pelo dígito menos significativo
  
 $\proc{Radix-Sort}(A, n, d)$
\vspace{-2.0cm}
\begin{tabbing}
~~~~ \= ~~~~\= ~~~~\= ~~~~\= ~~~~~~~\= \hspace*{12cm}                               \=   \\
1  \> \For $i = 1$ \To  $d$  \textbf{\blue faça}\> \> \> \> \>  \\
2  \> \> ordena $A[1..n]$ pelo n-ésimo dígito com um algarismo \textbf{estável}\> \> \> \>   \\
\end{tabbing} 
\end{slide}
 
 
\begin{slide}
    \stitle{Radix-Sort}  
\begin{center}
\includegraphics[width=.7\textwidth]{fig03}
\end{center}
\end{slide}
 
 
\begin{slide}
    \stitle{Complexidade do Radix-Sort}  
    A análise do tempo de execução depende da ordenação estável usada como algoritmo ordenação intermediária. 
    
    Usando o $\proc{Counting-Sort}$ para dígitos na faixa $[0\cdots k-1]$, a complexidade de pior caso é $\Theta(d(n+k))$ 
    
Se $k=O(n)$ e $d=O(1)$, então $T(n) = \Theta(n)$.

Note que se for utilizada, por exemplo, $\proc{Insertion-Sort}$, como algoritmo estável a complexidade de tempo \textbf{não será} a linear.
\end{slide}
 
 
\begin{slide}
    \stitle{Bucket-Sort (Ordenação por "balde")}  
\end{slide}
 
\begin{slide}
    \stitle{Bucket-Sort (Ordenação por "balde")}  
 Os $n$ elementos do vetor são valores reais distribuídos uniformemente em $[0,1)$
    
   Divide-se o intervalor $[0,1)$ em $n$ buckets de mesmo tamanho e distribui-se os $n$ elementos nos respectivos buckets 
   
   Cada bucket é ordenado por um método "qualquer" 
   
   Por fim, os buckets ordenados são concatenados em ordem crescente
   \end{slide}
 
 
\begin{slide}
    \stitle{Baldes}  
    
Entrada: 29 25 3 49 9 37 21 43 
 
\begin{center}
\includegraphics[width=.8\textwidth]{fig04}
\end{center}    


Saída: 3 9 21 25 29 37 43 49

\end{slide}
  

\begin{slide}
    \stitle{Bucket-Sort (Ordenação por "balde")}  
\begin{codebox}
\Procname{$\proc{Bucket-Sort}(A, n)$}
\li  \For $i=0$ \To $n-1$ 
\li  \Do   $B[i] = null$ 
\End
\li  \For $i=1$ \To $n$ 
\li  \Do insira $A[i]$ na lista $B[\lfloor n \cdot A[i] \rfloor]$
\End
\li  \For $i=0$ \To $n-1$ 
\li  \Do   $\proc{Insertion-Sort}(B[i])$
\End
\li  Concatene as listas $B[0], B[1], \cdots, B[n-1]$
\End
\end{codebox}  
\end{slide}
  
\begin{slide}
    \stitle{Exemplo}   
    
    \begin{center}
\includegraphics[width=.6\textwidth]{fig05}
\end{center}    
\end{slide}


\begin{slide}
    \stitle{Complexidade do Bucket-Sort}  
    \textbf{Pior caso:} Supondo $\proc{Insertion-Sort}$ para ordenar as listas $\Theta(n^2)$
    
    \textbf{Caso médio:} Número de elementos em cada lista é $\Theta(1)$, e o tempo esperado para ordenar uma lista $B[i]$ também é $\Theta(1)$
    
    \textbf{Melhor caso:} $\Theta(n)$
    
    \textbf{Complexidade de espaço:} $\Theta(n)$
\end{slide}


\begin{slide}
    \stitle{Dicas de website}      
   \url{https://www.cs.usfca.edu/~galles/visualization/CountingSort.html}
   
   \url{https://www.cs.usfca.edu/~galles/visualization/RadixSort.html}
   
  \url{ https://www.cs.usfca.edu/~galles/visualization/BucketSort.html}
  
  Neste mesmo site tem visualizações de outros algoritmos
\end{slide}
  

\begin{slide}
  \stitle{Obrigado}
\end{slide}

\end{document}

% Local Variables: 
% mode: latex
% eval: (Portug-mode)
% TeX-master: t
% End: 
